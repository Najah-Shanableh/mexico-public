### Documentation
# This script creates a function that runs through a bunch of different models on a variety of subsets of the data (with the superset stored in the Postgres location nick.municipality_model_data.
# It will output its results into a folder defined by the user-input variable "main_output_dir". This output is generated by the script model_iteration_output.Rmd which get called by knitr at the end. The location of model_iteration_output.Rmd is defined by a global variable "rmd_dir"
# This script is meant to be imported by another script, "model_variations.R", which will run through a bunch of loops and variations of this function.

### Setup
library(RPostgreSQL)
library(randomForest)
library(glmnet)
library(rpart)
library(knitr)
library(Hmisc)
library(ROCR)
# library(leaps)
# library(dplyr)
# library(car)
# library(lme4)
# library(MASS)
# library(psych)
# library(caret)
# library(party)

# ### Test Parameters
# subsetData_method <- "all" #c("all", "no0", "no1", "popThresh")
# varRemove_method <- "none" #c("manual", "auto", "none")
# getIndeps_method <- "reg" #c("reg", "interact")
# getDeps_method <- "mmr" #c("mmrThresh", "deathsThresh", "mmr")
# getWeights_method <- "popBirth" #c("popBirth", "none")
# nfolds <- 10
# alpha <- .5
# seed_set <- TRUE
# 
# knitNow <- function(){
#   opts_knit$set(base.dir=main_output_dir)
#   knit2html("nick/model_iteration_output.Rmd", output=file.path(main_output_dir, "test_model_output.html"))
#   browseURL(file.path(main_output_dir, "test_model_output.html"), browser="/usr/bin/open -a 'Google Chrome'")
# }
# 
# main_output_dir <- "/Users/Nicke/Desktop/mexico_model_outputs"
# rmd_dir <- "/Users/Nicke/Desktop/DSSG/mexico/nick"

runModels <- function(main_output_dir, subsetData_method, varRemove_method, getIndeps_method, getDeps_method, getWeights_method, nfolds, alpha, seed_set){
  db <- dbConnect(dbDriver("PostgreSQL"),
                  host='',
                  dbname='mexico',
                  user='',
                  password=''
  )
  
  model_start_time <- Sys.time()
  
  ### Process parameters
  main_output_dir <- main_output_dir
  getDeps_method <- getDeps_method
  getWeights_method <- getWeights_method
  subsetData_method <- subsetData_method
  varRemove_method <- varRemove_method
  getIndeps_method <- getIndeps_method
  nfolds <- nfolds
  alpha <- alpha
  if(seed_set==TRUE){set.seed(7)}
  
  ### Output Directory
  sub_output_dir <- paste0("S_", subsetData_method, "_R_", varRemove_method, "_I_", getIndeps_method, "_D_", getDeps_method, "_W_", getWeights_method)
  output_dir <- file.path(main_output_dir, sub_output_dir)
  dir.create(output_dir, showWarnings = FALSE, recursive=TRUE)
  
  ### Sink output
  sink_output <- file(file.path(output_dir, "sink_output.Rout"), open="w+")
  sink(sink_output, type="message")
  message("test sink")
  
  ### Get Data
  #sql_query <- "/Users/Nicke/Desktop/DSSG/mexico/scripts/model_datasets/municipality.sql"
  #data <- dbGetQuery(db, readChar(sql_query, file.info(sql_query)$size))
  data <- dbGetQuery(db, "SELECT * FROM nick.municipality_model_data")
  str(data)
  row.names(data) <- data$municipality
  
  ### Check to see where this is null info for localities
  datasets_data = data[,c('municipality', 'pop_total', 'pob_tot')]
  odd_municipalities <- sum(!complete.cases(datasets_data))
  # Percent of deaths that will be thrown out
  odd_municipality_deaths_pct <- sum(data$deaths[!complete.cases(datasets_data)])/sum(data$deaths) * 100
  # Take out problematic municipalities
  data <- data[complete.cases(datasets_data),]
  
  message("got data")
  
  ### Set up additional variables
  data <- within(data,{
    pct_rural_lcl <- rural_localities/n_localities
    pct_urban_lcl <- urban_localities/n_localities
    doctors_per_cap <- doctors/pop_total
    gyn_per_cap <- gynecologists/pop_total
    pct_gyn <- gynecologists/doctors
    pct_urban_pop <- urban_pop/pob_tot
    pct_rural_pop <- rural_pop/pob_tot
    pct_rural1_pop <- rural1_pop/pob_tot
    pct_rural2_pop <- rural2_pop/pob_tot
    pct_rural3_pop <- rural3_pop/pob_tot
    pct_rural4_pop <- rural4_pop/pob_tot
    rural_inst_per_rcap <- rural_institutions/rural_pop
    urban_inst_per_ucap <- urban_institutions/urban_pop
    rural_inst_per_cap <- rural_institutions/pop_total
    urban_inst_per_cap <- urban_institutions/pop_total
    preg_beds_per_pop_birth <- pregnancy_beds/pop_birth
    pct_other_institutions <- other_institutions/num_institutions
    pct_imss_institutions <- imss_institutions/num_institutions
    pct_issste_institutions <- issste_institutions/num_institutions
    pct_ssa_institutions <- ssa_institutions/num_institutions
    pct_opportunitidades_institutions <- opportunidades_institutions/num_institutions
    ssa_inst_per_ins <- ssa_institutions / ((pct_sp_insured/100)*pop_total)
    imss_inst_per_ins <- imss_institutions / ((pct_imss_insured/100)*pop_total)
    issste_inst_per_ins <- issste_institutions / ((pct_issste_insured/100)*pop_total)
    imss_issste_per_ins <- (imss_institutions + issste_institutions) / (((pct_imss_insured + pct_issste_insured)/100)*pop_total)
    opportunidades_inst_per_cap <- opportunidades_institutions / pop_total
    pct_attended_birth_doctor <- attended_birth_doctor / births
    pct_attended_birth_nurse <- attended_birth_nurse / births
    pct_attended_birth_midwife <- attended_birth_midwife / births
    pct_attended_birth_unspecified <- attended_birth_unspecified / births
    pct_birth_normal <- birth_procedure_normal / births
    pct_birth_cesarean <- birth_procedure_cesarean / births
    pct_birth_forceps <- birth_procedure_forceps / births
    pct_birth_other <- birth_procedure_other / births
    pct_birth_unspecified <- birth_procedure_unspecified / births
    pct_fetus_single <- fetus_single / births
    pct_fetus_twins <- fetus_twins / births
    pct_fetus_three_plus <- fetus_three_plus / births
    pct_fetus_unspecified <- fetus_unspecified / births
    pct_insurance_none <- insurance_none / births
    pct_insurance_imss_issste <- (insurance_imss + insurance_issste) / births
    pct_insurance_sp <- insurance_sp / births
    pct_insurance_opportunidades <- insurance_opportunidades / births
    pct_insurance_other <- insurance_other / births
    pct_insurance_unspecified <- insurance_unspecified / births
    pct_prenatal_yes <- prenatal_yes / births
    pct_prenatal_no <- prenatal_no / births
    pct_prenatal_unspecified <- prenatal_unspecified / births
  })
  # Impute missing/erroneus values
  data <- within(data,{
    imss_issste_per_ins <- impute(imss_issste_per_ins, 0)
    issste_inst_per_ins <- impute(issste_inst_per_ins, 0)
    imss_inst_per_ins <- impute(imss_inst_per_ins, 0)
    ssa_inst_per_ins <- impute(ssa_inst_per_ins, 0)
    pct_opportunitidades_institutions <- impute(pct_opportunitidades_institutions, 0)
    pct_ssa_institutions <- impute(pct_ssa_institutions, 0)
    pct_issste_institutions <- impute(pct_issste_institutions, 0)
    pct_imss_institutions <- impute(pct_imss_institutions, 0)
    pct_other_institutions <- impute(pct_other_institutions, 0)
    urban_inst_per_ucap <- impute(urban_inst_per_ucap, 0)
    rural_inst_per_rcap <- impute(rural_inst_per_rcap, 0)
    pct_gyn <- impute(pct_gyn, 0)
    urban_clue_distance <- impute(urban_clue_distance, max)
    rural_clue_distance <- impute(rural_clue_distance, max)
    urban_loc_distance <- impute(urban_loc_distance, max)
    rural_loc_distance <- impute(rural_loc_distance, max)
    urban_basico_distance <- impute(urban_basico_distance, max)
    rural_basico_distance <- impute(rural_basico_distance, max)
    ssa_inst_per_ins[is.finite(ssa_inst_per_ins)==FALSE] <- max(ssa_inst_per_ins[is.finite(ssa_inst_per_ins)==TRUE])
    pct_no_contraceptive <- impute(pct_no_contraceptive, median)
    pct_contraceptive <- impute(pct_contraceptive, median)
    pct_md_pregnancy <- impute(pct_md_pregnancy, 0)
    pct_md_birth <- impute(pct_md_birth, 0)
    pct_md_puerperium <- impute(pct_md_puerperium, 0)
    pct_md_b_o10 <- impute(pct_md_b_o10, 0)      
    pct_md_b_o60 <- impute(pct_md_b_o60, 0)
    pct_md_b_o94 <- impute(pct_md_b_o94, 0)
    pct_md_b_o30 <- impute(pct_md_b_o30, 0)        
    pct_md_b_o85 <- impute(pct_md_b_o85, 0)
    pct_md_b_o00 <- impute(pct_md_b_o00, 0)
    pct_md_b_o20 <- impute(pct_md_b_o20, 0)
    pct_md_b_other <- impute(pct_md_b_other, 0)
    sp_mismatch <- impute(sp_mismatch, 0)
    opportunidades_mismatch <- impute(opportunidades_mismatch, 0)
    iio_mismatch <- impute(iio_mismatch, 0)     
  })
  
  message("added and imputed variables")
  
  ### Subset dataset
  subsetData <- function(subsetData_method){
    if(subsetData_method=="all"){
      data <<- data
    } else if(subsetData_method=="no0"){
      data <<- subset(data, deaths > 0)
    } else if(subsetData_method=="no1"){
      data <<- subset(data, deaths > 1) 
    } else if(subsetData_method=="popThresh"){
      mmrate <- data$deaths / data$pop_birth
      data_pop_birth_mmrate0 <- data$pop_birth[mmrate==0]
      pop_thresh <- quantile(data_pop_birth_mmrate0)[4]*1.5
      data <<- subset(data, pop_birth > pop_thresh)
    } else if(subsetData_method=="no0_limit"){
      data <<- subset(data, pop_total <= 50000 & deaths > 0)
    } else { stop("subsetData() problem!") }
  }
  subsetData(subsetData_method)
  deaths_dist <- data$deaths
  mmr_dist <- data$deaths / data$pop_birth
  
  message("subsetted data")
  
  ### Generate dependent variables and weights since they might be dropped later
  getDeps <- function(getDeps_method){
    # Create different dependent variables based on the model
    dep <- list()
    mmrate <- data$deaths/data$pop_birth
    if(getDeps_method=="mmrThresh"){
      # Make MMRate threshold at 75th percentile
      dep$lasso.logit <- as.factor(ifelse(mmrate > quantile(mmrate)[[4]], 1, 0))
      dep$logit <- dep$lasso.logit
      dep$linear <- dep$lasso.logit
      dep$tree <- dep$lasso.logit
      dep$poisson <- dep$lasso.logit
    } else if(getDeps_method=="deathsThresh"){
      ndeaths_thresh <- 1
      dep$lasso.logit <- as.factor(ifelse(data$deaths > ndeaths_thresh, 1, 0))
      dep$logit <- dep$lasso.logit
      dep$linear <- dep$lasso.logit
      dep$tree <- dep$lasso.logit
      dep$poisson <- dep$lasso.logit
    } else if(getDeps_method=="mmr"){
      if(getWeights_method=="popBirth"){
        dep$lasso.logit <- cbind(data$pop_birth - data$deaths, data$deaths)
        dep$logit <- cbind(data$deaths, data$pop_birth - data$deaths)
      } else if (getWeights_method=="none"){
        dep$lasso.logit <- mmrate
        dep$logit <- mmrate
      } else { stop("getDeps() problem!")}
      dep$linear <- mmrate
      dep$tree <- mmrate
      dep$poisson <- mmrate
    } else { stop("getDeps() problem!") }
    return(dep)
  }
  dep <- getDeps(getDeps_method)
  # Create list of dependent variables to be taken out in modeling
  dep_vars <- c("deaths", "dep", "death_rt", "pct_maternal_deaths")
  
  message("generated dependent variables")
  
  getWeights <- function(getWeights_method){
    if(getWeights_method=="popBirth"){
      return(data$pop_birth)
    } else if(getWeights_method=="none"){
      return(rep(1, nrow(data)))
    } else { stop("getWeights() problem!")}
  }
  weights <- getWeights(getWeights_method)
  
  message("generated weights")
  
  ### Additional alterations for model data
  # Check to see which values are still null
  null_vars <- c()
  for(column in names(data)){
    if(sum(!is.na(data[[column]])) < nrow(data)){
      print(column)
      print(sum(!is.na(data[[column]])))
      null_vars <- c(null_vars, column)
    }
  }
  # Check to see which vars are string vars
  string_vars <- c()
  for(column in names(data)){
    if(is.character(data[[column]])){
      string_vars <- c(string_vars, column)
    }
  }
  # Check to see which values are infinite
  infinite_vars <- c()
  for(column in names(data)){
    if(sum(is.finite(data[[column]])) < nrow(data) & !(column %in% string_vars) & !(column %in% null_vars)){
      print(column)
      print(sum(is.finite(data[[column]])))
      infinite_vars <- c(infinite_vars, column)
    }
  }
  # Take out variables with any missing values
  data <- data[,!(names(data) %in% null_vars)]
  # Take out character vars
  data <- data[,!(names(data) %in% string_vars)]
  # Determine percent of complete cases
  complete_cases_pct <- nrow(data[complete.cases(data),]) / nrow(data) * 100
  
  ### Take out correlated variables
  varRemove <- function(varRemove_method){
    
    # Manual Method
    if(varRemove_method=="manual"){
      # Bring variables down to set that's been inspected
      known_vars <- c("nom_ent", "nom_mun", "pop_total", "pop_birth", "pop_fem", "ent", "n_localities", "pob_tot", "no_read", "no_ed", "no_toilet", "no_electricity", "no_water", "people_per_room", "dirt_floor", "no_fridge", "margination", "urban_pop", "rural_pop", "rural1_pop", 
                      "rural2_pop", "rural3_pop", "rural4_pop", "urban_localities", "rural_localities", "deaths", "num_institutions", "imss_institutions", "issste_institutions", "ssa_institutions", "opportunidades_institutions", "other_institutions", "rural_institutions", "urban_institutions", 
                      "pregnancy_beds", "post_pregnancy_beds", "newborn_beds", "labor_rooms", "ultrasound_systems", "doctors", "family_physicians", "gynecologists", "nurses", "pct_indig_hhlds", "pct_born_here", "pct_catholic", "pct_protestant", "pct_other_religion", "pct_non_religion", "pct_entitled_health_serv", 
                      "pct_no_health_serv", "pct_imss_insured", "pct_issste_insured", "pct_sp_insured", "pct_other_insured", "pct_single", "pct_hh_fem", "pct_hh_u30", "pct_hh_30t59", "pct_hh_60p", "avg_children_born", "avg_children_born_alive", "pct_15t19_birth", "avg_fem_edu", "avg_edu", "pct_edu_post_basic", 
                      "pct_edu_basic", "pct_edu_ms", "pct_edu_hs", "pct_illiterate", "pct_econ_active", "pct_primary_degree", "pct_secondary_degree", "pct_superior_degree", "pct_post_grad", "pct_fem_econ_active", "pct_fem_primary_degree", "pct_fem_post_grad", "pct_unemployed", "pct_fem_employed", "pct_no_school", "pct_fem_no_school", 
                      "pct_disabilies", "pct_occupied_dwellings", "births", "attended_birth_doctor", "attended_birth_nurse", "attended_birth_ssa", "attended_birth_midwife", "attended_birth_other", "attended_birth_unspecified", "birth_procedure_normal", "birth_procedure_cesarean", "birth_procedure_forceps", "birth_procedure_other", 
                      "birth_procedure_unspecified", "fetus_single", "fetus_twins", "fetus_three_plus", "fetus_unspecified", "insurance_none", "insurance_imss", "insurance_issste", "insurance_sp", "insurance_opportunidades", "insurance_other", "insurance_unspecified", "avg_prenatal_consults", "pob_ssa", "pob_opportunidades", "pob_imss", "pob_issste", 
                      "pob_other_gov_inst", "pob_other_private", "pob_public_place", "pob_household", "pob_other", "pob_unspecified", "avg_mother_pregnancies", "prenatal_yes", "prenatal_no", "prenatal_unspecified", "clue_distance", "loc_distance", "urban_clue_distance", "rural_clue_distance", "urban_loc_distance", "rural_loc_distance")
      cor_vars <- c()
      # Population correlated--leave in pop_birth
      cor_vars <- c(cor_vars, "pop_total", "pop_fem", "pob_tot", "urban_pop", "rural_pop", "rural1_pop", "rural2_pop", "rural3_pop", "rural4_pop", "urban_localities", "rural_localities", "num_institutions", "imss_institutions", "issste_institutions", "ssa_institutions", "opportunidades_institutions", "other_institutions", "rural_institutions", "urban_institutions", "pregnancy_beds", "post_pregnancy_beds", "newborn_beds", "labor_rooms", "ultrasound_systems", "doctors", "family_physicians", "gynecologists", "nurses", "births", "attended_birth_doctor", "attended_birth_nurse", "attended_birth_ssa", "attended_birth_midwife", "attended_birth_other", "attended_birth_unspecified", "birth_procedure_normal", "birth_procedure_cesarean", "birth_procedure_forceps", "birth_procedure_other", "birth_procedure_unspecified", "fetus_single", "fetus_twins", "fetus_three_plus", "fetus_unspecified", "insurance_none", "insurance_imss", "insurance_issste", "insurance_sp", "insurance_opportunidades", "insurance_other", "insurance_unspecified", "pob_ssa", "pob_opportunidades", "pob_imss", "pob_issste", "pob_other_gov_inst", "pob_other_private", "pob_public_place", "pob_household", "pob_other", "pob_unspecified", "prenatal_yes", "prenatal_no", "prenatal_unspecified")
      # Margination correlated--leave in margination
      cor_vars <- c(cor_vars, "no_read", "no_ed", "pct_no_school", "pct_fem_no_school", "people_per_room", "no_fridge")
      # Education correlated--leave in avg_edu
      cor_vars <- c(cor_vars, "avg_fem_edu", "pct_edu_post_basic", "pct_edu_ms", "pct_edu_hs", "pct_illiterate", "pct_superior_degree", "pct_post_grad")
      # Economics correlated--leave in pct_econ_active
      cor_vars <- c(cor_vars, "pct_fem_econ_active")
      # Distance correlated--leave in clue_distances
      cor_vars <- c(cor_vars, "urban_loc_distance", "rural_loc_distance")
      # Institutions per cap correlated--leave in isste_inst_per_ins
      cor_vars <- c(cor_vars, "imss_issste_per_ins")
      # Rural population correlated--leave in pct_rural_pop
      cor_vars <- c(cor_vars, "urban_clue_distance", "urban_loc_distance", "pct_urban_pop")
      # Insurance correlated--leave in pct_sp_insured and pct_no_heath_serv
      cor_vars <- c(cor_vars, "pct_imss_insured", "pct_entitled_health_serv")
      # Household correlated--leave in pct_hh_60p
      cor_vars <- c(cor_vars, "pct_hh_30t59")
      # Birth procedure correlated--leave in pct_birth_cesarean, prenatal_yes, fetus_twins
      cor_vars <- c(cor_vars, "pct_birth_normal", "prenatal_yes", "fetus_single")
      
      # Bring model down to variables that have been inspected
      data <<- data[,names(data %in% known_vars)]
      # Remove variables that were bad
      data <<- data[,!(names(data) %in% cor_vars)]

    # Automatic method
    } else if(varRemove_method=="auto"){
      createHighCors <- function(cor_thresh){
        high.cor.vars <- data.frame()
        cor <- data.frame(cor(data))
        for(column in names(cor)){
          num_cor_vars <- sum(abs(cor[column]) > cor_thresh) - 1
          if(num_cor_vars > 0){
            avg_cor <- mean(abs(cor[column][abs(cor[column]) > cor_thresh & rownames(cor)!=column]))
            temp.frame <- data.frame("avg_cor" = avg_cor, "num_cor_vars" = num_cor_vars, row.names=column)
            high.cor.vars <- rbind(high.cor.vars, temp.frame)
          }
        }
        try(high.cor.vars <- high.cor.vars[order(-high.cor.vars$num_cor_vars, -high.cor.vars$avg_cor),], silent=TRUE)
        return(high.cor.vars)
      }
      cor_thresh <- .9
      high.cor.vars <- createHighCors(cor_thresh)
      while(nrow(high.cor.vars) > 0){
        print(rownames(high.cor.vars)[1])
        print(high.cor.vars$num_cor_vars[1])
        print(high.cor.vars$avg_cor[1])
        data <<- data[,names(data) != rownames(high.cor.vars)[1]]
        high.cor.vars <- createHighCors(cor_thresh)
      }
    
    # No removal
    } else if(varRemove_method=="none"){
      data <<- data
    } else { stop("varRemove() problem!") }
  }
  varRemove(varRemove_method)
  
  message("removed variables")
  
  ### Models
  # Create independent variables matrix
  getIndeps <- function(method){
    if(method=="reg"){ 
      return(as.matrix(data[,!(names(data) %in% dep_vars)])) 
    } else if(method=="interact"){ 
      return(model.matrix(~.^2-1, data[,!(names(data) %in% dep_vars)])) 
    } else { stop("getIndeps() problem!") }
  }
  indep <- getIndeps(getIndeps_method)
  scaled.indep <- scale(indep)
  
  # Generate linear LASSO model
#   try({
#     lasso.linear <- glmnet(scaled.indep, as.numeric(dep$linear), weights=weights, alpha=alpha)
#     coef(lasso.linear)
#     plot(lasso.linear, label=TRUE)
#     print(lasso.linear)
#     write.csv(as.matrix(lasso.linear), file.path(output_dir, "lasso_linear_dev.csv"))
#     write.csv(as.matrix(coef(lasso.linear)), file.path(output_dir, "lasso_linear_coef.csv"))
#   })
#   try({
#     cv.lasso.linear <- cv.glmnet(scaled.indep, as.numeric(dep$linear), weights=weights, alpha=alpha, nfolds=nfolds)
#     plot(cv.lasso.linear)
#     cv.lasso.linear.coef.min <- subset(as.matrix(coef(cv.lasso.linear, s="lambda.min")), coef(cv.lasso.linear, s="lambda.min")[,1]!=0)
#     cv.lasso.linear.coef.1se <- subset(as.matrix(coef(cv.lasso.linear, s="lambda.1se")), coef(cv.lasso.linear, s="lambda.1se")[,1]!=0)
#     cv.lasso.linear.coef.min[order(-cv.lasso.linear.coef.min),,drop=FALSE]
#     cv.lasso.linear.coef.1se[order(-cv.lasso.linear.coef.1se),,drop=FALSE]
#   })
  
  # Generate binomial LASSO model
  try({
    lasso.logit <- glmnet(scaled.indep, dep$lasso.logit, family="binomial", alpha=alpha)
    coef(lasso.logit)
    plot(lasso.logit, label=TRUE)
    print(lasso.logit)
    write.csv(as.matrix(lasso.logit), file.path(output_dir, "lasso_logit_dev.csv"))
    write.csv(as.matrix(coef(lasso.logit)), file.path(output_dir, "lasso_logit_coef.csv"))
  })
  try({
    cv.lasso.logit <- cv.glmnet(scaled.indep, dep$lasso.logit, family="binomial", alpha=alpha, nfolds=nfolds)
    plot(cv.lasso.logit)
    cv.lasso.logit.coef.min <- subset(as.matrix(coef(cv.lasso.logit, s="lambda.min")), coef(cv.lasso.logit, s="lambda.min")[,1]!=0)
    cv.lasso.logit.coef.1se <- subset(as.matrix(coef(cv.lasso.logit, s="lambda.1se")), coef(cv.lasso.logit, s="lambda.1se")[,1]!=0)
    cv.lasso.logit.coef.min[order(-cv.lasso.logit.coef.min),,drop=FALSE]
    cv.lasso.logit.coef.1se[order(-cv.lasso.logit.coef.1se),,drop=FALSE]
  })
  
  # Generate poisson LASSO model
#   try({
#     lasso.poisson <- glmnet(scaled.indep, dep$poisson, weights=weights, family="poisson", alpha=alpha)
#     coef(lasso.poisson)
#     plot(lasso.poisson, label=TRUE)
#     print(lasso.poisson)
#     write.csv(as.matrix(lasso.poisson), file.path(output_dir, "lasso_poisson_dev.csv"))
#     write.csv(as.matrix(coef(lasso.poisson)), file.path(output_dir, "lasso_poisson_coef.csv"))
#   })
#   try({
#     cv.lasso.poisson <- cv.glmnet(scaled.indep, dep$poisson, family="poisson", alpha=alpha, nfolds=nfolds)
#     plot(cv.lasso.poisson)
#     cv.lasso.poisson.coef.min <- subset(as.matrix(coef(cv.lasso.poisson, s="lambda.min")), coef(cv.lasso.poisson, s="lambda.min")[,1]!=0)
#     cv.lasso.poisson.coef.1se <- subset(as.matrix(coef(cv.lasso.poisson, s="lambda.1se")), coef(cv.lasso.poisson, s="lambda.1se")[,1]!=0)
#     cv.lasso.poisson.coef.min[order(-cv.lasso.poisson.coef.min),,drop=FALSE]
#     cv.lasso.poisson.coef.1se[order(-cv.lasso.poisson.coef.1se),,drop=FALSE]
#   })
  
  message("generated LASSO models")
  
  # CHAID
  try({
    if(class(dep$tree)=="factor"){
      chaid_method <- "class"
    } else{ chaid_method <- "anova" }
    chaid <- rpart(dep$tree ~ ., data=as.data.frame(indep), method=chaid_method, weights=weights)
    summary(chaid)
    plot(chaid, uniform=TRUE)
    text(chaid, use.n=TRUE, all=TRUE, cex=.8)
    printcp(chaid)
    plotcp(chaid)
    sort(chaid$variable.importance, decreasing = TRUE)[1:20]
  })
    
  # CHAID Poisson
#   try({
#     chaid.poisson <- rpart(dep$tree ~ ., data=as.data.frame(indep), method="poisson", weights=weights)
#     summary(chaid.poisson)
#     plot(chaid.poisson, uniform=TRUE)
#     text(chaid.poisson, use.n=TRUE, all=TRUE, cex=.8)
#     printcp(chaid.poisson)
#     plotcp(chaid.poisson)
#   })    
    
  # Random Forest
  try({
    if(getWeights_method=="none"){
      random_forest_weights <- NULL
    } else if(getWeights_method=="popBirth"){
      if(class(dep$tree)=="factor"){
        weights.aggregate <- aggregate(weights, by=list(dep=dep$tree), sum)
        random_forest_weights <- weights.aggregate$x
      } else{ random_forest_weights <- weights }
    } else { stop("randomForest weights problem!")}
    random.forest <- randomForest(indep, dep$tree, classwt=random_forest_weights, importance=TRUE)
    print(random.forest)
    importance(random.forest)
    write.csv(importance(random.forest), file.path(output_dir, "random_forest_importance.csv"))
    varImpPlot(random.forest)
  })
    
  message("generated trees")
  
  ### Validate Variables
  # Linear model 1se
#   try({
#     linear.lasso.coef.1se <- coef(cv.lasso.linear, s="lambda.1se")
#     linear.variables.1se <- rownames(subset(as.matrix(linear.lasso.coef.1se), linear.lasso.coef.1se[,1]!=0))
#     linear.variables.1se <- linear.variables.1se[linear.variables.1se!="(Intercept)"]
#     linear.matrix.1se <- subset(scaled.indep, select=c(linear.variables.1se))
#     linear.model.1se <- glm(dep$linear ~ ., data=as.data.frame(linear.matrix.1se), weights=weights)
#     summary(linear.model.1se)
#     anova(linear.model.1se, "Chisq")
#     hist(residuals(linear.model.1se), breaks=nrow(linear.matrix.1se))
#     summary(residuals(linear.model.1se)^2)
#     summary(abs(residuals(linear.model.1se)))
#     residual.tree.linear.1se <- rpart(residuals(linear.model.1se) ~ ., data=as.data.frame(indep), method="anova", weights=weights)
#     plot(residual.tree.linear.1se, uniform=TRUE)
#     text(residual.tree.linear.1se, use.n=TRUE, all=TRUE, cex=.8)
#   })
  
  # Linear model min
#   try({
#     linear.lasso.coef.min <- coef(cv.lasso.linear, s="lambda.min")
#     linear.variables.min <- rownames(subset(as.matrix(linear.lasso.coef.min), linear.lasso.coef.min[,1]!=0))
#     linear.variables.min <- linear.variables.min[linear.variables.min!="(Intercept)"]
#     linear.matrix.min <- subset(scaled.indep, select=c(linear.variables.min))
#     linear.model.min <- glm(as.numeric(dep$linear) ~ ., data=as.data.frame(linear.matrix.min), weights=weights)
#     summary(linear.model.min)
#     anova(linear.model.min, "Chisq")
#     hist(residuals(linear.model.min), breaks=nrow(linear.matrix.min))
#     summary(residuals(linear.model.min)^2)
#     summary(abs(residuals(linear.model.min)))
#     residual.tree.linear.min <- rpart(residuals(linear.model.min) ~ ., data=as.data.frame(indep), method="anova", weights=weights)
#     plot(residual.tree.linear.min, uniform=TRUE)
#     text(residual.tree.linear.min, use.n=TRUE, all=TRUE, cex=.8)
#     plotcp(residual.tree.linear.min)
#   })
  
  # Logit model 1se
  try({
    logit.lasso.coef.1se <- coef(cv.lasso.logit, s="lambda.1se")
    logit.variables.1se <- rownames(subset(as.matrix(logit.lasso.coef.1se), logit.lasso.coef.1se[,1]!=0))
    logit.variables.1se <- logit.variables.1se[logit.variables.1se!="(Intercept)"]
    logit.matrix.1se <- subset(scaled.indep, select=c(logit.variables.1se))
    logit.model.1se <- glm(dep$logit ~ ., data=as.data.frame(logit.matrix.1se), family="binomial")
    summary(logit.model.1se)
    anova(logit.model.1se, "Chisq")
    hist(residuals(logit.model.1se), breaks=nrow(logit.matrix.1se))
    summary(residuals(logit.model.1se)^2)
    summary(abs(residuals(logit.model.1se)))
    residual.tree.logit.1se <- rpart(residuals(logit.model.1se) ~ ., data=as.data.frame(indep), method="anova", weights=weights)
    plot(residual.tree.logit.1se, uniform=TRUE)
    text(residual.tree.logit.1se, use.n=TRUE, all=TRUE, cex=.8)
    plotcp(residual.tree.logit.min)
  })
  
  # Logit model min
#   try({
#     logit.lasso.coef.min <- coef(cv.lasso.logit, s="lambda.min")
#     logit.variables.min <- rownames(subset(as.matrix(logit.lasso.coef.min), logit.lasso.coef.min[,1]!=0))
#     logit.variables.min <- logit.variables.min[logit.variables.min!="(Intercept)"]
#     logit.matrix.min <- subset(scaled.indep, select=c(logit.variables.min))
#     logit.model.min <- glm(dep$logit ~ ., data=as.data.frame(logit.matrix.min), family="binomial")
#     summary(logit.model.min)
#     anova(logit.model.min, "Chisq")
#     hist(residuals(logit.model.min), breaks=nrow(logit.matrix.min))
#     summary(residuals(logit.model.min)^2)
#     summary(abs(residuals(logit.model.min)))
#     residual.tree.logit.min <- rpart(residuals(logit.model.min) ~ ., data=as.data.frame(indep), method="anova", weights=weights)
#     plot(residual.tree.logit.min, uniform=TRUE)
#     text(residual.tree.logit.min, use.n=TRUE, all=TRUE, cex=.8)
#     plotcp(residual.tree.logit.min)
#   })
  
  # Poisson model 1se
#   try({
#     poisson.lasso.coef.1se <- coef(cv.lasso.poisson, s="lambda.1se")
#     poisson.variables.1se <- rownames(subset(as.matrix(poisson.lasso.coef.1se), poisson.lasso.coef.1se[,1]!=0))
#     poisson.variables.1se <- poisson.variables.1se[poisson.variables.1se!="(Intercept)"]
#     poisson.matrix.1se <- subset(scaled.indep, select=c(poisson.variables.1se))
#     poisson.model.1se <- glm(dep$poisson ~ ., data=as.data.frame(poisson.matrix.1se), family="poisson")
#     summary(poisson.model.1se)
#     anova(poisson.model.1se, "Chisq")
#     hist(residuals(poisson.model.1se), breaks=nrow(poisson.matrix.1se))
#     summary(residuals(poisson.model.1se)^2)
#     summary(abs(residuals(poisson.model.1se)))
#     residual.tree.poisson.1se <- rpart(residuals(poisson.model.1se) ~ ., data=as.data.frame(indep), method="anova", weights=weights)
#     plot(residual.tree.poisson.1se, uniform=TRUE)
#     text(residual.tree.poisson.1se, use.n=TRUE, all=TRUE, cex=.8)
#   })
#   
#   # Poisson model min
#   try({
#     poisson.lasso.coef.min <- coef(cv.lasso.poisson, s="lambda.min")
#     poisson.variables.min <- rownames(subset(as.matrix(poisson.lasso.coef.min), poisson.lasso.coef.min[,1]!=0))
#     poisson.variables.min <- poisson.variables.min[poisson.variables.min!="(Intercept)"]
#     poisson.matrix.min <- subset(scaled.indep, select=c(poisson.variables.min))
#     poisson.model.min <- glm(dep$poisson ~ ., data=as.data.frame(poisson.matrix.min), family="poisson")
#     summary(poisson.model.min)
#     anova(poisson.model.min, "Chisq")
#     hist(residuals(poisson.model.min), breaks=nrow(poisson.matrix.min))
#     summary(residuals(poisson.model.min)^2)
#     summary(abs(residuals(poisson.model.min)))
#     residual.tree.poisson.min <- rpart(residuals(poisson.model.min) ~ ., data=as.data.frame(indep), method="anova", weights=weights)
#     plot(residual.tree.poisson.min, uniform=TRUE)
#     text(residual.tree.poisson.min, use.n=TRUE, all=TRUE, cex=.8)
#   })
  
  message("validated regression models")
  
  # CHAID anova
#   try({
#     hist(residuals(chaid), breaks=nrow(indep))
#     summary(residuals(chaid))
#     summary(abs(residuals(chaid)))
#   })
    
#   # CHAID poisson
#   try({
#     hist(residuals(chaid.poisson), breaks=nrow(indep))
#     summary(residuals(chaid.poisson))
#     summary(abs(residuals(chaid.poisson)))
#   })  
  
  # Random Forest
  try({
    residuals.rf <- predict(random.forest) - dep$tree
#     hist(residuals.rf, breaks=nrow(data))
#     summary(residuals.rf)
#     summary(abs(residuals.rf))
  })
  
  message("validated trees")
  
  ### ROCs
#   predict.logit.min <- predict(logit.model.min, type="response")
#   prediction.logit.min <- prediction(predict.logit.min, dep$logit)
#   roc.logit.min <- performance(prediction.logit.min,measure="tpr", x.measure="fpr")
#   pr.logit.min <- performance(prediction.logit.min,measure="prec", x.measure="rec")
#   plot(roc.logit.min, col=2, lwd=2)
#   abline(a=0,b=1,lwd=2,lty=2,col="gray")
#   plot(pr.logit.min, col=2, lwd=2)
#   auc.logit.model.min <- unlist(slot(performance(prediction.logit.min,"auc"), "y.values"))
# 
#   predict.rf <- predict(random.forest, type="prob")[,2]
#   prediction.rf <- prediction(predict.rf, dep$tree)
#   performance.rf = performance(prediction.rf,"tpr","fpr")
#   plot(performance.rf, col=2, lwd=2)
#   abline(a=0,b=1,lwd=2,lty=2,col="gray")
#   auc.rf <- unlist(slot(performance(prediction.rf,"auc"), "y.values"))

  # Hierarchical model
  
  ### Principal Components Analysis
  pca <- prcomp(scaled.indep)

pca <- prcomp(indep, center=TRUE, scale=TRUE)
varimax <- varimax(pca$rotation)
oblique <- promax(pca$rotation)
screeplot(pca, type="lines")
screeplot(varimax, type="lines")
screeplot(oblique, type="lines")

principal(indep)

#   summary(pca)
#   # Can check scree plot to determine the component at which the variance explains shifts to be at a much lower rate per component
#   screeplot(pca, type="lines")
#   # Can also use Kaiser's criterion to determine number of components to retain--look for variances greater than 1
#   pca$sdev[pca$sdev^2>1]
#   # Check to see how much variance is explained by Kaiser's criterion
#   sum(pca$sdev[pca$sdev^2>1]^2)/sum(pca$sdev^2)
#   pca$rotation
#   plot(pca$x[,1], pca$x[,2])
#   
#   message("generated PCA")
  
  ### Write results to file
  # MAE Results
  model_end_time <- Sys.time()
  mae_linear.model.1se <- NA
  mae_linear.model.min <- NA
  mae_logit.model.1se <- NA
  mae_logit.model.min <- NA
  mae_poisson.model.1se <- NA
  mae_poisson.model.min <- NA
  mae_chaid <- NA
  mae_chaid.poisson <- NA
  mae_random.forest <- NA
  
#   try(mae_linear.model.1se <- summary(abs(residuals(linear.model.1se)))[4])
#   try(mae_linear.model.min <- summary(abs(residuals(linear.model.min)))[4])
  try(mae_logit.model.1se <- summary(abs(residuals(logit.model.1se)))[4])
#   try(mae_logit.model.min <- summary(abs(residuals(logit.model.min)))[4])
#   try(mae_poisson.model.1se <- summary(abs(residuals(poisson.model.1se)))[4])
#   try(mae_poisson.model.min <- summary(abs(residuals(poisson.model.min)))[4])
  try(mae_chaid <- summary(abs(residuals(chaid)))[4])
#   try(mae_chaid.poisson <- summary(abs(residuals(chaid.poisson)))[4])
#   try(mae_random.forest <- summary(abs(residuals.rf))[4])
  data_output <- paste(model_start_time, model_end_time, subsetData_method, varRemove_method, getIndeps_method, getDeps_method, getWeights_method,
                       nfolds, alpha, mae_linear.model.1se, mae_linear.model.min, mae_logit.model.1se, mae_logit.model.min,
                       mae_poisson.model.1se, mae_poisson.model.min, mae_chaid, mae_chaid.poisson, mae_random.forest, sep=",")
  header_output <- paste(model_start_time, model_end_time, "subsetData_method", "varRemove_method", "getIndeps_method", "getDeps_method", "getWeights_method",
                       "nfolds", "alpha", "mae_linear.model.1se", "mae_linear.model.min", "mae_logit.model.1se", "mae_logit.model.min",
                       "mae_poisson.model.1se", "mae_poisson.model.min", "mae_chaid", "mae_chaid.poisson", "mae_random.forest", sep=",")
  try({
    data_output_file <- file(file.path(main_output_dir, "model_data_output.txt"), open="a")
    writeLines(data_output, data_output_file)
    close(data_output_file)
  })
  try({
    header_output_file <- file(file.path(main_output_dir, "model_header_output.txt"), open="a")
    writeLines(header_output, header_output_file)
    close(header_output_file)
  })

  # Variable results
  try({
    logit.coefficients <- as.data.frame(summary(logit.model.min)$coefficients)
    logit.coefficients$subsetData_method <- subsetData_method
    logit.coefficients$varRemove_method <- varRemove_method
    logit.coefficients$getIndeps_method <- getIndeps_method
    logit.coefficients$getDeps_method <- getDeps_method
    logit.coefficients$getWeights_method <- getWeights_method
    logit.coefficients$nfolds <- nfolds
    logit.coefficients$alpha <- alpha
    logit.coefficients$method <- sub_output_dir
    write.table(logit.coefficients, file.path(main_output_dir, "logit_coefficients.txt"), sep=",", append=TRUE, col.names=FALSE)
  })

#   try({
#     linear.coefficients <- as.data.frame(summary(linear.model.min)$coefficients)
#     linear.coefficients$subsetData_method <- subsetData_method
#     linear.coefficients$varRemove_method <- varRemove_method
#     linear.coefficients$getIndeps_method <- getIndeps_method
#     linear.coefficients$getDeps_method <- getDeps_method
#     linear.coefficients$getWeights_method <- getWeights_method
#     linear.coefficients$nfolds <- nfolds
#     linear.coefficients$alpha <- alpha
#     linear.coefficients$method <- sub_output_dir
#     write.table(linear.coefficients, file.path(main_output_dir, "linear_coefficients.txt"), sep=",", append=TRUE, col.names=FALSE)
#   })
  
  try({
    chaid.variables <- sort(chaid$variable.importance, decreasing = TRUE)[1:20]
    chaid.variables <- as.data.frame(chaid.variables)
    chaid.variables$subsetData_method <- subsetData_method
    chaid.variables$varRemove_method <- varRemove_method
    chaid.variables$getIndeps_method <- getIndeps_method
    chaid.variables$getDeps_method <- getDeps_method
    chaid.variables$getWeights_method <- getWeights_method
    chaid.variables$nfolds <- nfolds
    chaid.variables$alpha <- alpha
    chaid.variables$method <- sub_output_dir
    write.table(chaid.variables, file.path(main_output_dir, "chaid_importances.txt"), sep=",", append=TRUE, col.names=FALSE)
  })
    
  message("wrote outputs")
  
  ### Knit a report
  try({
    opts_knit$set(base.dir=file.path(output_dir))
    knit2html(file.path(rmd_dir, "/model_iteration_output.Rmd"), output=file.path(output_dir, "model_diagnostics.html"))
  })
  message("Finished!")
  
  sink(file=NULL, type="message")
}
